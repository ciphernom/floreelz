--- START OF FILE: ./vite.config.d.ts ---

declare const _default: import("vite").UserConfig;
export default _default;

--- END OF FILE: ./vite.config.d.ts ---



--- START OF FILE: ./vite.config.ts ---

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { nodePolyfills } from 'vite-plugin-node-polyfills';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    nodePolyfills({ protocolImports: true }), // Polyfills process, global, etc.
    VitePWA({
      registerType: 'autoUpdate',
      devOptions: {
        enabled: true
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
        runtimeCaching: [
          {
            urlPattern: /wss:\/\//, // Match websocket connections
            handler: 'NetworkOnly' // Don't cache websockets
          },
          {
            // Cache Nostr events with network-first strategy
            urlPattern: ({ url }) => url.protocol === 'https:' && url.pathname.startsWith('/'),
            handler: 'NetworkFirst',
            options: {
              cacheName: 'nostr-events',
              expiration: {
                maxEntries: 200,
                maxAgeSeconds: 24 * 60 * 60 // 1 day
              }
            }
          }
        ]
      },
      manifest: {
        name: 'FloReelz',
        short_name: 'FloReelz',
        description: 'Decentralized Video Sharing on Nostr',
        theme_color: '#000000',
        background_color: '#000000',
        display: 'standalone',
        start_url: '/',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          }
        ]
      }
    }),
  ],
  optimizeDeps: {
    include: ['webtorrent'], // Force pre-bundling
  },
  resolve: {
    alias: {
      webtorrent: 'webtorrent/dist/webtorrent.min.js',
    },
  },
});

--- END OF FILE: ./vite.config.ts ---



--- START OF FILE: ./index.html ---

<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="ethereum-dapp" content="false">
  <title>FloReelz</title>
</head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

--- END OF FILE: ./index.html ---



--- START OF FILE: ./node_modules ---


--- END OF FILE: ./node_modules ---



--- START OF FILE: ./tsconfig.node.json ---

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
 
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": false,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,

    "composite": true
  },
  "include": ["vite.config.ts"]
}

--- END OF FILE: ./tsconfig.node.json ---



--- START OF FILE: ./src/components/UploadModal.tsx ---

import { useState } from 'react';
import { nostrClient } from '../core/nostr';
import { webTorrentClient } from '../core/webtorrent';
import { ipfsClient } from '../core/ipfs';
import { toast } from 'react-hot-toast';

const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB limit

const computeHash = async (file: File): Promise<string> => {
  const buffer = await file.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
};

const extractThumbnail = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.preload = 'metadata';
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return reject(new Error('Canvas context is not available'));

    video.onloadeddata = () => {
      video.currentTime = 1; // Seek to 1 second in
      video.onseeked = () => {
        canvas.width = 320;
        canvas.height = (video.videoHeight / video.videoWidth) * 320;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/webp', 0.8);
        URL.revokeObjectURL(video.src); // Clean up blob URL
        resolve(dataUrl);
      };
    };
    video.onerror = () => reject(new Error('Failed to load video for thumbnail extraction'));
    video.src = URL.createObjectURL(file);
  });
};

interface Props {
  isOpen: boolean;
  onClose: () => void;
}

function UploadModal({ isOpen, onClose }: Props) {
  const [file, setFile] = useState<File | null>(null);
  const [title, setTitle] = useState('');
  const [summary, setSummary] = useState('');
  const [isUploading, setIsUploading] = useState(false);

  const handleUpload = async () => {
    if (!file || !title || isUploading) {
      toast.error(!file ? 'Please select a file' : !title ? 'Please add a title' : 'Already uploading');
      return;
    }

    if (file.size > MAX_FILE_SIZE) {
      toast.error(`File too large! Maximum size is ${MAX_FILE_SIZE / (1024 * 1024)}MB`);
      return;
    }

    setIsUploading(true);
    const toastId = toast.loading('Seeding video to network. Please keep this tab open.');

    try {
      const magnetURI = await webTorrentClient.seed(file);
      toast.loading('Uploading to IPFS for persistence...', { id: toastId });
      const cid = await ipfsClient.uploadFile(file);
      console.log('‚úÖ Seeding complete! Magnet URI:', magnetURI);
      console.log('‚úÖ IPFS upload complete! CID:', cid);

      const [hash, thumbnail] = await Promise.all([
        computeHash(file),
        extractThumbnail(file).catch(() => undefined) // Don't block upload if thumbnail fails
      ]);
      console.log('üîê Computed hash:', hash);

      toast.loading('Publishing to Nostr...', { id: toastId });
      const event = await nostrClient.publishVideo(magnetURI, title, summary, hash, thumbnail, cid);
      console.log('‚úÖ Published to Nostr! Event ID:', event.id);

      toast.success('Upload complete!', { id: toastId });
      
      setFile(null);
      setTitle('');
      setSummary('');
      onClose();
    } catch (error) {
      console.error('‚ùå Upload failed:', error);
      toast.error('Upload failed. Check console for details.', { id: toastId });
    } finally {
      setIsUploading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <h2>Upload Video</h2>
        <input 
          type="text" 
          placeholder="Title" 
          value={title}
          onChange={e => setTitle(e.target.value)} 
        />
        <textarea 
          placeholder="Summary" 
          value={summary}
          onChange={e => setSummary(e.target.value)} 
        />
        <input 
          type="file" 
          accept="video/mp4" 
          onChange={e => setFile(e.target.files?.[0] || null)} 
        />
        <div className="modal-actions">
          <button onClick={onClose} disabled={isUploading}>Cancel</button>
          <button onClick={handleUpload} disabled={!file || !title || isUploading}>
            {isUploading ? 'Uploading...' : 'Upload'}
          </button>
        </div>
      </div>
    </div>
  );
}

export default UploadModal;

--- END OF FILE: ./src/components/UploadModal.tsx ---



--- START OF FILE: ./src/components/InteractionBar.tsx ---

import { useState } from 'react';
import { nostrClient } from '../core/nostr';
import { VideoData } from '../types';
import { toast } from 'react-hot-toast';

interface Props {
  video: VideoData;
}

function InteractionBar({ video }: Props) {
  const [isLiked, setIsLiked] = useState(nostrClient.likedVideos.has(video.id));
  const [showReportModal, setShowReportModal] = useState(false);

  const handleLike = async () => {
    const newLikedState = await nostrClient.likeVideo(video);
    setIsLiked(newLikedState);
    
    if (newLikedState) {
      toast('‚ù§Ô∏è Liked!');
    } else {
      toast('üíî Unliked');
    }
  };

  const handleReport = async (reason: string) => {
    try {
      await nostrClient.reportVideo(video.id, video.author, reason as any);
      toast.success('Report submitted');
      setShowReportModal(false);
    } catch (error) {
      toast.error('Failed to submit report');
    }
  };

  return (
    <>
      <div className="interaction-bar">
        <button 
          onClick={handleLike}
          style={{ color: isLiked ? 'red' : 'white' }}
        >
          ‚ù§Ô∏è
        </button>
        <button>üí¨</button>
        <button>üîó</button>
        <button onClick={() => setShowReportModal(true)} title="Report">
          ‚ö†Ô∏è
        </button>
      </div>

      {showReportModal && (
        <div className="modal-overlay" onClick={() => setShowReportModal(false)}>
          <div className="modal-content report-modal" onClick={e => e.stopPropagation()}>
            <h3>Report this video</h3>
            <div className="report-reasons">
              <button onClick={() => handleReport('spam')}>Spam</button>
              <button onClick={() => handleReport('nsfw')}>Inappropriate Content</button>
              <button onClick={() => handleReport('harassment')}>Harassment</button>
              <button onClick={() => handleReport('illegal')}>Illegal Content</button>
              <button onClick={() => handleReport('other')}>Other</button>
            </div>
            <button onClick={() => setShowReportModal(false)}>Cancel</button>
          </div>
        </div>
      )}
    </>
  );
}

export default InteractionBar;

--- END OF FILE: ./src/components/InteractionBar.tsx ---



--- START OF FILE: ./src/components/VideoFeed.tsx ---

import { useEffect, useState } from 'react';
import { Swiper, SwiperSlide } from 'swiper/react';
import { Mousewheel, Virtual } from 'swiper/modules';
import 'swiper/css';
import 'swiper/css/virtual';
import { VideoFeedSkeleton } from './SkeletonLoader';
import { nostrClient } from '../core/nostr';
import { getProfileManager } from '../core/profiles';
import { nip19 } from 'nostr-tools';
import { VideoData } from '../types';
import VideoPlayer from './VideoPlayer';
import InteractionBar from './InteractionBar';
import ProfileView from './ProfileView';

function VideoFeed() {
  const [videos, setVideos] = useState<VideoData[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedProfilePubkey, setSelectedProfilePubkey] = useState<string | null>(null);
  const [authorNames, setAuthorNames] = useState<Map<string, string>>(new Map());
  const [videoIds, setVideoIds] = useState<Set<string>>(new Set()); // Phase 3: Dedupe by ID for personalized feed
  useEffect(() => {
    const receivedIds = new Set<string>();
    const profileManager = getProfileManager();

    nostrClient.subscribeToVideos(async (video) => {
      if (receivedIds.has(video.id)) return;
      receivedIds.add(video.id);

      setVideos((prevVideos) => {
       // Phase 3: Sort by recency, limit to 50 for performance
       const updated = [video, ...prevVideos].sort((a, b) => b.createdAt - a.createdAt).slice(0, 50);
       return updated;
      });

      try {
        const profile = await profileManager.getProfile(video.author);
        if (profile && profile.name) {
          setAuthorNames((prev) => new Map(prev).set(video.author, profile.name!));
        }
      } catch (error) {
        console.error('Failed to load author profile:', error);
      }

      setIsLoading(false);
    });

    return () => {
      nostrClient.unsubscribeFromVideos();
    };
  }, []);

  if (isLoading) {
    return <VideoFeedSkeleton />;
  }

  if (videos.length === 0) {
    return (
      <div style={{ padding: '20px', textAlign: 'center', color: 'white' }}>
        <h2>No videos yet!</h2>
        <p>Upload the first video to get started, or wait for new content to be published.</p>
      </div>
    );
  }

  return (
    <>
      <Swiper
        direction={'vertical'}
        className="swiper-container"
        modules={[Mousewheel, Virtual]}
        mousewheel
        virtual
      >
        {videos.map((video, index) => {
          const npub = nip19.npubEncode(video.author);
          const authorName = authorNames.get(video.author);
          const displayName = authorName || `${npub.slice(0, 12)}...${npub.slice(-4)}`;

          return (
            <SwiperSlide key={video.id} virtualIndex={index} className="slide">
              {({ isActive }) => (
                <>
                  <VideoPlayer
                    magnetURI={video.magnetURI}
                    hash={video.hash}
                    cid={video.cid} // Phase 3: Pass CID for fallback
                    isActive={isActive}
                  />
                  <div className="overlay-info">
                    <h3>{video.title}</h3>
                    <p>{video.summary}</p>
                    <p 
                      className="author"
                      onClick={() => setSelectedProfilePubkey(video.author)}
                      style={{ cursor: 'pointer', textDecoration: 'underline' }}
                    >
                      By: {displayName}
                    </p>
                  </div>
                  <InteractionBar video={video} />
                </>
              )}
            </SwiperSlide>
          );
        })}
      </Swiper>

      {selectedProfilePubkey && (
        <ProfileView
          pubkey={selectedProfilePubkey}
          onClose={() => setSelectedProfilePubkey(null)}
        />
      )}
    </>
  );
}

export default VideoFeed;

--- END OF FILE: ./src/components/VideoFeed.tsx ---



--- START OF FILE: ./src/components/SkeletonLoader.tsx ---

import React from 'react';

const SkeletonBar: React.FC<{ width?: string; height?: string; className?: string }> = ({
  width = '100%',
  height = '16px',
  className = '',
}) => <div className={`skeleton-bar ${className}`} style={{ width, height }} />;

export const VideoFeedSkeleton: React.FC = () => (
  <div className="video-feed-skeleton">
    <div className="skeleton-video-player">
      <div className="skeleton-overlay">
        <SkeletonBar width="80%" height="24px" />
        <SkeletonBar width="60%" height="16px" />
        <SkeletonBar width="40%" height="16px" className="author" />
      </div>
      <div className="skeleton-interaction-bar">
        <div className="skeleton-icon" />
        <div className="skeleton-icon" />
        <div className="skeleton-icon" />
        <div className="skeleton-icon" />
      </div>
    </div>
  </div>
);

export const ProfileSkeleton: React.FC = () => (
  <div className="profile-skeleton">
    <div className="profile-skeleton-header">
      <div className="skeleton-avatar" />
      <div style={{ flex: 1 }}>
        <SkeletonBar width="50%" height="24px" />
        <SkeletonBar width="30%" height="16px" />
      </div>
    </div>
    <div className="profile-skeleton-stats">
      <SkeletonBar width="40px" height="30px" />
      <SkeletonBar width="40px" height="30px" />
      <SkeletonBar width="40px" height="30px" />
    </div>
    <SkeletonBar width="100%" height="40px" />
    <div className="profile-skeleton-grid">
      {[...Array(9)].map((_, i) => (
        <div key={i} className="skeleton-thumbnail" />
      ))}
    </div>
  </div>
);

--- END OF FILE: ./src/components/SkeletonLoader.tsx ---



--- START OF FILE: ./src/components/VideoPlayer.tsx ---

import { useEffect, useRef, useState } from 'react';
import { webTorrentClient } from '../core/webtorrent';
import { ipfsClient } from '../core/ipfs'; // Phase 3: For IPFS fallback
import './VideoPlayer.css';

interface Props {
  magnetURI: string;
  hash?: string;
  cid?: string; // Phase 3: Add prop for fallback
  isActive: boolean;
}

function VideoPlayer({ magnetURI, hash, isActive }: Props) {
  const [isMuted, setIsMuted] = useState(() => localStorage.getItem('videoMuted') === 'true');
  const videoRef = useRef<HTMLVideoElement>(null);
  const [error, setError] = useState<string | null>(null);
  const currentMagnetRef = useRef<string>('');

  useEffect(() => {
    let mounted = true;
    const videoElement = videoRef.current;
    
    if (isActive && videoElement && magnetURI && mounted) {
      if (currentMagnetRef.current !== magnetURI) {
        // Reset state for new video
        setError(null); 
        videoElement.src = '';
        currentMagnetRef.current = magnetURI;

       // Phase 3: Try WebTorrent first, fallback to IPFS after timeout
       const tryStream = async () => {
         try {
           await Promise.race([
             webTorrentClient.stream(magnetURI, videoElement, hash),
             new Promise((_, reject) => 
               setTimeout(() => reject(new Error('No WebTorrent peers')), 10000) // 10s timeout
             )
           ]);
         } catch (err: any) {
           if (err.message === 'No WebTorrent peers' && cid) {
             console.log('üîÑ Falling back to IPFS');
             const ipfsUrl = await ipfsClient.getFileUrl(cid);
             videoElement.src = ipfsUrl;
             videoElement.load();
           } else {
             throw err;
           }
         }
       };
       
       tryStream().catch((err) => {
         if (mounted) {
           setError(err.message || 'Failed to load video');
         }
       });

        
        videoElement.addEventListener('error', () => {
          if (mounted) {
            setError('Video playback error');
          }
        });
      }
    } else if (videoElement && mounted) {
      videoElement.pause();
    }
    
    return () => {
      mounted = false;
    };
  }, [isActive, magnetURI, hash]);

  useEffect(() => {
    if (videoRef.current) {
      videoRef.current.muted = isMuted;
    }
  }, [isMuted]);

  const toggleMute = () => {
    const newMutedState = !isMuted;
    setIsMuted(newMutedState);
    localStorage.setItem('videoMuted', String(newMutedState));
  };

  const handleRetry = () => {
    setError(null);
    if (videoRef.current) {
      videoRef.current.src = '';
      videoRef.current.load();
    }
    // Re-trigger load if needed
    if (currentMagnetRef.current === magnetURI && isActive) {
      webTorrentClient.stream(magnetURI, videoRef.current!, hash).catch(setError);
    }
  };

  if (error) {
    return (
      <div className="video-player error-container">
        <div className="error-overlay">
          <p>{error}</p>
          <button onClick={handleRetry}>Retry</button>
        </div>
      </div>
    );
  }

  return (<>
      <video
        ref={videoRef}
        className="video-player"
        loop
        playsInline
        autoPlay={isActive}
        controls={false} // Use custom controls
        onClick={toggleMute}
       // Phase 3: Ensure SW caches video fetches
       crossOrigin="anonymous"
      />
      {isActive && (
        <button className="mute-btn" onClick={toggleMute} aria-label="Toggle Mute">
          {isMuted ? 'üîá' : 'üîä'}
        </button>
      )}
  </>);
}

export default VideoPlayer;

--- END OF FILE: ./src/components/VideoPlayer.tsx ---



--- START OF FILE: ./src/components/ProfileView.tsx ---

import { useState, useEffect } from 'react';
import { getProfileManager, UserProfile } from '../core/profiles';
import { nostrClient } from '../core/nostr';
import { nip19 } from 'nostr-tools';
import { toast } from 'react-hot-toast';
import { ProfileSkeleton } from './SkeletonLoader';
import { VideoData } from '../types';
import './ProfileView.css';

interface Props {
  pubkey?: string;
  onClose: () => void;
  onVideoSelect?: (video: VideoData) => void;
}

interface ProfileStats {
  following: number;
  followers: number;
  likes: number;
}

type TabType = 'videos' | 'liked' | 'private';

function ProfileView({ pubkey, onClose, onVideoSelect }: Props) {
  const profileManager = getProfileManager();
  const isOwnProfile = !pubkey || pubkey === nostrClient.publicKey;
  const targetPubkey = pubkey || nostrClient.publicKey;
  
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [profileError, setProfileError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [activeTab, setActiveTab] = useState<TabType>('videos');
  const [userVideos, setUserVideos] = useState<VideoData[]>([]);
  const [videosError, setVideosError] = useState<string | null>(null);
  const [likedVideos, setLikedVideos] = useState<VideoData[]>([]);
  const [likedError, setLikedError] = useState<string | null>(null);
  const [canZap, setCanZap] = useState(false);
  const [stats, setStats] = useState<ProfileStats>({
    following: 0,
    followers: 0,
    likes: 0
  });
  const [isFollowing, setIsFollowing] = useState(false);
  const [followError, setFollowError] = useState<string | null>(null);
  const [showKeyExport, setShowKeyExport] = useState(false);
  
  const [editForm, setEditForm] = useState({
    name: '',
    about: '',
    picture: '',
  });

  useEffect(() => {
    const init = async () => {
      setIsLoading(true);
      setProfileError(null);
      setVideosError(null);
      setFollowError(null);

¬† ¬† ¬† if (!targetPubkey) {
¬† ¬† ¬† ¬† setIsLoading(false);
¬† ¬† ¬† ¬† return;
¬† ¬† ¬† }

      try {
        const promises = [
          loadProfile(),
          loadUserVideos(),
          loadStats(),
        ];

        if (!isOwnProfile) {
          promises.push(checkFollowStatus());
        }

        await Promise.allSettled(promises);
      } catch (error) {
        console.error('Failed to initialize profile:', error);
        toast.error('Failed to load profile data');
      } finally {
        setIsLoading(false);
      }
    };

    init();
  }, [targetPubkey, isOwnProfile]);

  useEffect(() => {
    if (activeTab === 'liked' && isOwnProfile && likedVideos.length === 0) {
      loadLikedVideos();
    }
  }, [activeTab]);

  const loadProfile = async () => {
  if (!targetPubkey) return;
    try {
      const p = await profileManager.getProfile(targetPubkey);
      setProfile(p);
      setEditForm({
        name: p.name || '',
        about: p.about || '',
        picture: p.picture || '',
      });
      // Check for LUD-16 (Lightning Address) and ensure not viewing own profile
      setCanZap(!!(p.lud16 && !isOwnProfile));
      setProfileError(null);
    } catch (error) {
      console.error('Failed to load profile:', error);
      setProfileError('Could not load profile');
      setProfile(null);
      toast.error('Failed to load profile');
    }
  };

  const loadUserVideos = async () => {
  if (!targetPubkey) return;
    try {
      const videos = await nostrClient.getUserVideos(targetPubkey);
      setUserVideos(videos);
      setVideosError(null);
    } catch (error) {
      console.error('Failed to load user videos:', error);
      setUserVideos([]);
      setVideosError('Could not load videos');
      toast.error('Failed to load videos');
    }
  };

  const loadLikedVideos = async () => {
    try {
      const videos = await nostrClient.getLikedVideos();
      setLikedVideos(videos);
      setLikedError(null);
    } catch (error) {
      console.error('Failed to load liked videos:', error);
      setLikedVideos([]);
      setLikedError('Could not load liked videos');
      toast.error('Failed to load liked videos');
    }
  };

  const loadStats = async () => {
  if (!targetPubkey) return;
    try {
      const userStats = await nostrClient.getUserStats(targetPubkey);
      setStats(userStats);
    } catch (error) {
      console.error('Failed to load stats:', error);
      setStats({ following: 0, followers: 0, likes: 0 });
      toast.error('Failed to load stats');
    }
  };

  const checkFollowStatus = async () => {
  if (!targetPubkey) return;
    try {
      const following = await nostrClient.isFollowing(targetPubkey);
      setIsFollowing(following);
      setFollowError(null);
    } catch (error) {
      console.error('Failed to check follow status:', error);
      setFollowError('Could not check follow status');
      toast.error('Failed to check follow status');
    }
  };

  const handleFollow = async () => {
  if (!targetPubkey) return;
    try {
      if (isFollowing) {
        await nostrClient.unfollow(targetPubkey);
        setIsFollowing(false);
        setStats(prev => ({ ...prev, followers: Math.max(0, prev.followers - 1) }));
        toast.success('Unfollowed');
      } else {
        await nostrClient.follow(targetPubkey);
        setIsFollowing(true);
        setStats(prev => ({ ...prev, followers: prev.followers + 1 }));
        toast.success('Following');
      }
      setFollowError(null);
    } catch (error) {
      console.error('Failed to update follow status:', error);
      setFollowError('Failed to update follow');
      toast.error('Failed to update follow status');
    }
  };

  const handleSave = async () => {
  if (!targetPubkey) return;
    setIsSaving(true);
    try {
      await profileManager.updateMyProfile(editForm);
      setProfile({ ...profile, ...editForm, pubkey: targetPubkey });
      setIsEditing(false);
      toast.success('Profile updated!');
    } catch (error) {
      toast.error('Failed to save profile');
    } finally {
      setIsSaving(false);
    }
  };

  const handleShare = () => {
  if (!targetPubkey) return;
    const npub = nip19.npubEncode(targetPubkey);
    navigator.clipboard.writeText(`nostr:${npub}`);
    toast.success('Profile link copied!');
  };

  const handleZap = async () => {
    if (!profile?.lud16 || !targetPubkey) {
      toast.error("User doesn't have a Lightning Address set up.");
      return;
    }
    try {
      // The amount is hardcoded for simplicity, but could be a modal input
      await nostrClient.zapUser(targetPubkey, profile.lud16, 100);
    } catch (error) {
      console.error('Zap failed in component:', error);
      // The nostrClient itself will show a more specific error toast
    }
  };

  const handleExportKeys = async () => {
  if (!nostrClient.publicKey) return;
    try {
      const secretKey = await nostrClient.getSecretKey();
      const nsec = nip19.nsecEncode(secretKey);
      const npub = nip19.npubEncode(nostrClient.publicKey!);
      
      const keyData = `NOSTR PRIVATE KEY (KEEP SECRET!):\n${nsec}\n\nPUBLIC KEY:\n${npub}`;
      
      navigator.clipboard.writeText(keyData);
      toast.success('Keys copied to clipboard! Keep them safe!', { duration: 5000 });
    } catch (error: any) {
      if (error.message.includes('NIP-07') || error.message.includes('extension')) {
        toast('Your keys are managed by the Nostr extension. Check your extension settings to export.');
      } else {
        toast.error('Failed to export keys');
      }
    }
    setShowKeyExport(false);
  };

  const formatNumber = (num: number): string => {
    if (num >= 1000000) {
      return `${(num / 1000000).toFixed(1)}M`;
    }
    if (num >= 10000) {
      return `${(num / 1000).toFixed(1)}K`;
    }
    return num.toString();
  };

  if (isLoading) {
        return <div className="tiktok-profile-container"><ProfileSkeleton /></div>;
  }
  // guard clause right after the loading checks
  if (!targetPubkey) {
    return (
      <div className="tiktok-profile-container">
        <div className="loading-spinner"></div>
      </div>
    );
   }
  if (profileError) {
    return (
      <div className="tiktok-profile-container">
        <div className="error-overlay">
          <p>{profileError}</p>
          <button onClick={loadProfile}>Retry</button>
        </div>
      </div>
    );
  }

  const npub = nip19.npubEncode(targetPubkey);
  const displayName = profile?.name || 'Anonymous';
  const username = `@${npub.slice(5, 13)}...${npub.slice(-4)}`;

  return (
    <div className="tiktok-profile-container">
      {/* Header */}
      <div className="tiktok-profile-header">
        <button className="back-button" onClick={onClose}>
          <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
            <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
          </svg>
        </button>
        <span className="header-username">{displayName}</span>
        <div className="header-actions">
          {isOwnProfile && (
            <button className="settings-button" onClick={() => setShowKeyExport(!showKeyExport)}>
              <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
              </svg>
            </button>
          )}
          <button className="more-button" onClick={handleShare}>
            <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
              <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
            </svg>
          </button>
        </div>
      </div>

      {/* Key Export Modal */}
      {showKeyExport && isOwnProfile && (
        <div className="key-export-modal">
          <h3>Export Keys</h3>
          <p>‚ö†Ô∏è WARNING: Never share your private key!</p>
          <button onClick={handleExportKeys}>Copy Keys to Clipboard</button>
          <button onClick={() => setShowKeyExport(false)}>Cancel</button>
        </div>
      )}

      {/* Profile Info Section */}
      <div className="tiktok-profile-info">
        <div className="profile-avatar-section">
          {isEditing ? (
            <div className="avatar-edit-container">
              <img 
                src={editForm.picture || `https://robohash.org/${targetPubkey}`}
                alt={displayName}
                className="profile-avatar"
                onError={(e) => {
                  (e.target as HTMLImageElement).src = `https://robohash.org/${targetPubkey}`;
                }}
              />
              <input
                type="url"
                className="avatar-url-input"
                placeholder="Profile picture URL"
                value={editForm.picture}
                onChange={(e) => setEditForm({ ...editForm, picture: e.target.value })}
              />
            </div>
          ) : (
            <img 
              src={profile?.picture || `https://robohash.org/${targetPubkey}`}
              alt={displayName}
              className="profile-avatar"
              onError={(e) => {
                (e.target as HTMLImageElement).src = `https://robohash.org/${targetPubkey}`;
              }}
            />
          )}
        </div>

        {isEditing ? (
          <div className="edit-form">
            <input
              type="text"
              className="edit-name"
              placeholder="Name"
              value={editForm.name}
              onChange={(e) => setEditForm({ ...editForm, name: e.target.value })}
              maxLength={30}
            />
            <textarea
              className="edit-bio"
              placeholder="Bio"
              value={editForm.about}
              onChange={(e) => setEditForm({ ...editForm, about: e.target.value })}
              maxLength={80}
              rows={2}
            />
          </div>
        ) : (
          <>
            <h1 className="profile-display-name">{displayName}</h1>
            <p className="profile-username">{username}</p>
          </>
        )}

        {/* Stats */}
        <div className="profile-stats">
          <div className="stat-item">
            <span className="stat-number">{formatNumber(stats.following)}</span>
            <span className="stat-label">Following</span>
          </div>
          <div className="stat-item">
            <span className="stat-number">{formatNumber(stats.followers)}</span>
            <span className="stat-label">Followers</span>
          </div>
          <div className="stat-item">
            <span className="stat-number">{formatNumber(stats.likes)}</span>
            <span className="stat-label">Likes</span>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="profile-actions">
          {isOwnProfile ? (
            isEditing ? (
              <div className="edit-actions">
                <button className="cancel-button" onClick={() => {
                  setEditForm({
                    name: profile?.name || '',
                    about: profile?.about || '',
                    picture: profile?.picture || '',
                  });
                  setIsEditing(false);
                }}>
                  Cancel
                </button>
                <button className="save-button" onClick={handleSave} disabled={isSaving}>
                  {isSaving ? 'Saving...' : 'Save'}
                </button>
              </div>
            ) : (
              <button className="edit-profile-button" onClick={() => setIsEditing(true)}>
                Edit profile
              </button>
            )
          ) : (
            <div className="follow-actions">
              <button 
                className={`follow-button ${isFollowing ? 'following' : ''}`}
                onClick={handleFollow}
                disabled={!!followError}
              >
                {followError ? 'Error' : isFollowing ? 'Following' : 'Follow'}
              </button>

              {canZap && (
                <button className="zap-button" onClick={handleZap} title="Send a Lightning tip">
                  ‚ö° Zap
                </button>
              )}

              <button className="message-button">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
                </svg>
              </button>
            </div>
          )}
        </div>

        {/* Bio */}
        {!isEditing && profile?.about && (
          <p className="profile-bio">{profile.about}</p>
        )}
      </div>

      {/* Tabs */}
      <div className="profile-tabs">
        <button 
          className={`tab-button ${activeTab === 'videos' ? 'active' : ''}`}
          onClick={() => setActiveTab('videos')}
        >
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
            <path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z"/>
          </svg>
        </button>
        <button 
          className={`tab-button ${activeTab === 'liked' ? 'active' : ''}`}
          onClick={() => setActiveTab('liked')}
        >
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
          </svg>
        </button>
        {isOwnProfile && (
          <button 
            className={`tab-button ${activeTab === 'private' ? 'active' : ''}`}
            onClick={() => setActiveTab('private')}
          >
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
              <path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/>
            </svg>
          </button>
        )}
      </div>

      {/* Video Grid */}
      <div className="video-grid">
        {activeTab === 'videos' && (
          videosError ? (
            <div className="empty-state error-state">
              <p>{videosError}</p>
              <button onClick={loadUserVideos}>Retry</button>
            </div>
          ) : userVideos.length > 0 ? (
            userVideos.map((video) => (
              <div 
                key={video.id} 
                className="video-thumbnail"
                onClick={() => {
                  onVideoSelect?.(video);
                  onClose();
                }}
              >
                {video.thumbnail ? (
                  <img src={video.thumbnail} alt={video.title} className="video-thumbnail-img" loading="lazy" />
                ) : (
                  <div className="thumbnail-placeholder">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                    <path d="M8 5v14l11-7z"/>
                  </svg>
                </div>
                 )}
                <div className="thumbnail-info">
                  <p className="video-title">{video.title}</p>
                  <div className="video-stats">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="white">
                      <path d="M8 5v14l11-7z"/>
                    </svg>
                    <span>{Math.floor(Math.random() * 10000)}</span>
                  </div>
                </div>
              </div>
            ))
          ) : (
            <div className="empty-state">
              <p>{isOwnProfile ? 'Upload your first video!' : 'No videos yet'}</p>
            </div>
          )
        )}
        
        {activeTab === 'liked' && (
          isOwnProfile ? (
            likedError ? (
              <div className="empty-state error-state">
                <p>{likedError}</p>
                <button onClick={loadLikedVideos}>Retry</button>
              </div>
            ) : likedVideos.length > 0 ? (
              likedVideos.map((video) => (
                <div 
                  key={video.id} 
                  className="video-thumbnail"
                  onClick={() => {
                    onVideoSelect?.(video);
                    onClose();
                  }}
                >
                  <div className="thumbnail-placeholder">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                      <path d="M8 5v14l11-7z"/>
                    </svg>
                  </div>
                  <div className="thumbnail-info">
                    <p className="video-title">{video.title}</p>
                  </div>
                </div>
              ))
            ) : (
              <div className="empty-state">
                <p>No liked videos yet</p>
              </div>
            )
          ) : (
            <div className="empty-state">
              <svg width="48" height="48" viewBox="0 0 24 24" fill="#666">
                <path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/>
              </svg>
              <p>Only users can see their liked videos</p>
            </div>
          )
        )}
        
        {activeTab === 'private' && (
          <div className="empty-state">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="#666">
              <path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/>
            </svg>
            <p>Your private videos</p>
          </div>
        )}
      </div>
    </div>
  );
}

export default ProfileView;

--- END OF FILE: ./src/components/ProfileView.tsx ---



--- START OF FILE: ./src/App.tsx ---

import { useState } from 'react';
import VideoFeed from './components/VideoFeed';
import UploadModal from './components/UploadModal';
import ProfileView from './components/ProfileView';
import './index.css';
import { Toaster } from 'react-hot-toast';

function App() {
  const [isUploadModalOpen, setUploadModalOpen] = useState(false);
  const [isProfileOpen, setProfileOpen] = useState(false);

  return (
    <div className="app-container">
      <Toaster
        position="bottom-center"
        toastOptions={{
          style: {
            background: '#333',
            color: '#fff',
          },
        }}
      />
      
      <VideoFeed />
      
      {/* Profile Button */}
      <button 
        className="profile-btn-nav" 
        onClick={() => setProfileOpen(true)}
        aria-label="View profile"
      >
        üë§
      </button>
      
      {/* Upload Button */}
      <button 
        className="upload-btn" 
        onClick={() => setUploadModalOpen(true)}
        aria-label="Upload video"
      >
        +
      </button>
      
      <UploadModal
        isOpen={isUploadModalOpen}
        onClose={() => setUploadModalOpen(false)}
      />
      
      {isProfileOpen && (
        <ProfileView
          onClose={() => setProfileOpen(false)}
        />
      )}
    </div>
  );
}

export default App;

--- END OF FILE: ./src/App.tsx ---



--- START OF FILE: ./src/types.ts ---

import { Event } from 'nostr-tools';

export const VIDEO_KIND = 38234;

export interface VideoData {
  id: string;
  author: string;
  createdAt: number;
  magnetURI: string;
  title: string;
  summary: string;
  thumbnail?: string;
  hash?: string;
  cid?: string; // Phase 3: IPFS CID for persistence fallback
  hashtags: string[];
}

export type VideoEvent = Event;

--- END OF FILE: ./src/types.ts ---



--- START OF FILE: ./src/vite-env.d.ts ---

/// <reference types="vite/client" />

--- END OF FILE: ./src/vite-env.d.ts ---



--- START OF FILE: ./src/core/moderation.ts ---

// src/core/moderation.ts
export const REPORT_KIND = 1984;
export const REPORT_POW_DIFFICULTY = 12;
export const VELOCITY_THRESHOLD_REPORTS = 5; // Min reports for velocity check
export const VELOCITY_TIME_WINDOW = 300;     // 5min window in seconds
export const HIDE_THRESHOLD = 0.35;          // Reputation threshold for hiding

export type ReportReason =
  | 'spam'
  | 'nsfw'
  | 'illegal'
  | 'harassment'
  | 'other';
 

export class ModerationSystem {
  shouldHideVideo(uploaderReputation: number): boolean {
    return uploaderReputation < HIDE_THRESHOLD;
  }
}

--- END OF FILE: ./src/core/moderation.ts ---



--- START OF FILE: ./src/core/nostr.ts ---

import {
  generateSecretKey,
  getPublicKey,
  SimplePool,
  finalizeEvent,
  type UnsignedEvent,
} from 'nostr-tools';
import { minePow } from 'nostr-tools/nip13';
import { toast } from 'react-hot-toast';
import { bytesToHex, hexToBytes } from '@noble/hashes/utils';
import { VIDEO_KIND, VideoData, VideoEvent } from '../types';
import { ReputationManager } from './reputation';
import {
  ModerationSystem,
  ReportReason,
  REPORT_KIND,
  REPORT_POW_DIFFICULTY,
  VELOCITY_THRESHOLD_REPORTS,
  VELOCITY_TIME_WINDOW,
} from './moderation';

const RELAYS = [
  'wss://relay.damus.io',
  'wss://relay.snort.social',
  'wss://nos.lol',
];

const POW_DIFFICULTY = 10; // Configurable PoW difficulty for anti-spam


class NostrClient {
  private pool = new SimplePool();
  private secretKey: Uint8Array | null = null;
  public publicKey: string | null = null;
  private videoSub: ReturnType<typeof this.pool.subscribeMany> | null = null;
  public likedVideos: Set<string> = new Set();
  private moderationSystem = new ModerationSystem();
  public reputationManager: ReputationManager;
  private usingExtension: boolean = false;
  private extension: any = null;

  constructor() {
    console.log('üîê Initializing Nostr client...');
    
    this.extension = typeof window !== 'undefined' ? (window as any).nostr : null;
    this.usingExtension = !!this.extension;

    if (!this.usingExtension) {
      let sk = localStorage.getItem('nostr_sk');
      if (!sk) {
        this.secretKey = generateSecretKey();
        localStorage.setItem('nostr_sk', bytesToHex(this.secretKey));
        console.log('üÜï Generated new secret key');
      } else {
        this.secretKey = hexToBytes(sk);
        console.log('‚ôªÔ∏è Loaded existing secret key');
      }
      this.publicKey = getPublicKey(this.secretKey);
      console.log(`‚úÖ Logged in with public key: ${this.publicKey}`);
    } else {
      console.log('üîå Detected NIP-07 extension');
      this.publicKey = null;
      this.secretKey = null;
    }

    this.reputationManager = new ReputationManager();
  }

  private async ensureInitialized(): Promise<void> {
    if (this.publicKey) return;

    if (this.usingExtension) {
      try {
        this.publicKey = await this.extension.getPublicKey();
        console.log(`‚úÖ Using NIP-07 extension with pubkey: ${this.publicKey}`);
      } catch (e) {
        console.error('Failed to get pubkey from extension:', e);
        toast.error('Nostr extension required for signing');
        throw e;
      }
    }
  }

  private async signEvent(unsigned: UnsignedEvent): Promise<any> {
    await this.ensureInitialized();
    if (this.usingExtension) {
      return await this.extension.signEvent(unsigned);
    } else {
      return finalizeEvent(unsigned, this.secretKey!);
    }
  }

  public async getSecretKey(): Promise<Uint8Array> {
    if (this.usingExtension) {
      throw new Error('Using NIP-07 extension - no local secret key');
    }
    return this.secretKey!;
  }

  private async calculateVelocityPenalty(videoEventId: string): Promise<number> {
    const reports = await this.pool.querySync(RELAYS, {
      kinds: [REPORT_KIND],
      '#e': [videoEventId],
      limit: 10
    });
    
    if (reports.length < VELOCITY_THRESHOLD_REPORTS) {
      return 1.0;
    }
    
    const sortedReports = reports.sort((a, b) => a.created_at - b.created_at);
    const timeDelta = sortedReports[sortedReports.length - 1].created_at - sortedReports[0].created_at;
    
    if (timeDelta <= VELOCITY_TIME_WINDOW) {
      console.log(`üö® Velocity surge detected for ${videoEventId.slice(0,10)}... (${reports.length} reports in ${timeDelta}s)`);
      return 3.0;
    }
    
    return 1.0;
  }

  public async reportVideo(videoId: string, authorPubkey: string, reason: ReportReason): Promise<void> {
    await this.ensureInitialized();
    
    const velocityMultiplier = await this.calculateVelocityPenalty(videoId);
    this.reputationManager.recordReport(authorPubkey, this.publicKey!, velocityMultiplier);

    const event: UnsignedEvent = {
      kind: REPORT_KIND,
      created_at: Math.floor(Date.now() / 1000),
      pubkey: this.publicKey!,
      tags: [
        ['e', videoId, 'report'],
        ['p', authorPubkey],
        ['reason', reason],
      ],
      content: `Reported for: ${reason}`,
    };
    
    console.log(`‚õèÔ∏è Mining PoW for report (diff ${REPORT_POW_DIFFICULTY})...`);
    const minedEvent = minePow(event, REPORT_POW_DIFFICULTY);
    
¬† ¬† const signedEvent = await this.signEvent(minedEvent);
¬† ¬† await this.pool.publish(RELAYS, signedEvent);
¬† ¬† console.log('‚úÖ Report published');
  }

  public subscribeToVideos(onVideo: (video: VideoData) => void) {
   // Phase 3: Enhanced subscription for personalized discovery
   // First, get followed users for social feed
   this.getFollowedPubkeys().then(followed => {
     const filters = [{ kinds: [VIDEO_KIND], authors: followed, limit: 50 }];
     // Add filter for videos liked by followed users
     if (followed.length > 0) {
       filters.push({ kinds: [7], authors: followed, limit: 100 }); // Likes by followed
     }
     this.videoSub = this.pool.subscribeMany(RELAYS, filters, {
       onevent: async (event) => {
         // Handle video events and like events to fetch liked videos
         if (event.kind === VIDEO_KIND) {
           const videoData = this.parseVideoEvent(event as VideoEvent);
           // Dedupe by ID
           if (!Array.from(onVideo).some(v => v.id === videoData.id)) {
             const uploaderRep = this.reputationManager.getReputationScore(event.pubkey);
             if (!this.moderationSystem.shouldHideVideo(uploaderRep)) {
               onVideo(videoData);
             }
           }
         } else if (event.kind === 7) {
           // Fetch the liked video and add to feed if not already present
           const videoId = event.tags.find(t => t[0] === 'e')?.[1];
           if (videoId) {
             const videoEvent = await this.pool.querySync(RELAYS, { ids: [videoId], kinds: [VIDEO_KIND] });
             if (videoEvent.length > 0) {
               const videoData = this.parseVideoEvent(videoEvent[0] as VideoEvent);
               onVideo(videoData); // Will dedupe in caller
             }
           }
         }
       },
       oneose: () => console.log('‚úÖ Personalized feed loaded')
     });
   }).catch(err => {
     console.error('Failed to load followed for personalized feed:', err);
     // Fallback to global feed
     this.videoSub = this.pool.subscribeMany(RELAYS, [{ kinds: [VIDEO_KIND], limit: 20 }], {
       onevent: (event) => {
         const videoData = this.parseVideoEvent(event as VideoEvent);
         const uploaderRep = this.reputationManager.getReputationScore(event.pubkey);
         if (!this.moderationSystem.shouldHideVideo(uploaderRep)) {
           onVideo(videoData);
         }
       }
     });
   });
 }

 private async getFollowedPubkeys(): Promise<string[]> {
   await this.ensureInitialized();
   const events = await this.pool.querySync(RELAYS, {
     kinds: [3],
     authors: [this.publicKey!],
     limit: 1
   });
   if (events.length === 0) return [];
   return events[0].tags
     .filter(t => t[0] === 'p')
     .map(t => t[1]);
 }
  public unsubscribeFromVideos() {
    if (this.videoSub) {
      this.videoSub.close();
      this.videoSub = null;
    }
  }

  public async publishVideo(magnetURI: string, title: string, summary: string, hash: string, thumbnail?: string) {
    await this.ensureInitialized();
    
    console.log('üì§ Publishing video to Nostr:', {
      title,
      summary,
      magnetURI: magnetURI.substring(0, 50) + '...',
      hash: hash.substring(0, 16) + '...', 
      cid // Phase 3: Log CID if present
    });

    const event: UnsignedEvent = {
      kind: VIDEO_KIND,
      created_at: Math.floor(Date.now() / 1000),
      pubkey: this.publicKey!,
      tags: [
        ['d', title],
        ['magnet', magnetURI],
        ['title', title],
        ['summary', summary],
        ['hash', hash],
        ...(thumbnail ? [['thumbnail', thumbnail]] : []),
        ...(cid ? [['cid', cid]] : []), // Phase 3: Add CID tag for IPFS fallback
      ],
      content: `${title} - ${summary}`,
    };
    
    const toastId = toast.loading(`Mining Proof of Work (difficulty ${POW_DIFFICULTY})...`);
    console.time('‚õèÔ∏è PoW Mining');
    
    const minedEvent = minePow(event, POW_DIFFICULTY);
    console.timeEnd('‚õèÔ∏è PoW Mining');
    
    toast.dismiss(toastId);
    toast.loading('Signing and publishing...');

    const signedEvent = await this.signEvent(minedEvent);
    
    await this.pool.publish(RELAYS, signedEvent);
    
    toast.success('Published!');
    
    console.log('‚úÖ Published video event:', signedEvent);
    
    return signedEvent;
  }

  public async likeVideo(video: VideoData) {
    await this.ensureInitialized();
    
    const isLiked = this.likedVideos.has(video.id);
    
    if (isLiked) {
      this.likedVideos.delete(video.id);
      toast('üíî Unliked');
      return false;
    } else {
      this.likedVideos.add(video.id);
      
      let event: UnsignedEvent = {
        kind: 7,
        created_at: Math.floor(Date.now() / 1000),
        pubkey: this.publicKey!,
        tags: [
          ['e', video.id],
          ['p', video.author],
        ],
        content: '‚ù§Ô∏è',
      };

      event = minePow(event, POW_DIFFICULTY);

      const signedEvent = await this.signEvent(event);
      await this.pool.publish(RELAYS, signedEvent);
      
      this.reputationManager.recordLike(video.author, this.publicKey!);
      
      toast('‚ù§Ô∏è Liked!');
      return true;
    }
  }

  private parseVideoEvent(event: VideoEvent): VideoData {
    const findTag = (name: string) => {
      const tag = event.tags.find((t: string[]) => t[0] === name)?.[1] || '';
      return tag;
    };
    
    return {
      id: event.id!,
      author: event.pubkey,
      createdAt: event.created_at,
      thumbnail: findTag('thumbnail'),
      magnetURI: findTag('magnet'),
      title: findTag('title'),
      summary: findTag('summary'),
      hash: findTag('hash'),
      cid: findTag('cid'), // Phase 3: Parse CID for fallback
      hashtags: event.tags.filter((t: string[]) => t[0] === 't').map((t: string[]) => t[1]),
    };
  }
  
  private userVideosCache = new Map<string, VideoData[]>();

  public async getUserVideos(pubkey: string): Promise<VideoData[]> {
    if (this.userVideosCache.has(pubkey)) {
      return this.userVideosCache.get(pubkey)!;
    }

    const events = await this.pool.querySync(RELAYS, {
      kinds: [VIDEO_KIND],
      authors: [pubkey],
      limit: 100
    });
    
    const videos = events
      .map(event => this.parseVideoEvent(event as VideoEvent))
      .sort((a, b) => b.createdAt - a.createdAt);
    
    this.userVideosCache.set(pubkey, videos);
    
    return videos;
  }

  public async getUserStats(pubkey: string): Promise<{
    following: number;
    followers: number;
    likes: number;
  }> {
    await this.ensureInitialized();
    
    const followingEvents = await this.pool.querySync(RELAYS, {
      kinds: [3],
      authors: [pubkey],
      limit: 1
    });
    
    let followingCount = 0;
    if (followingEvents.length > 0) {
      followingCount = followingEvents[0].tags.filter(t => t[0] === 'p').length;
    }
    
    const followerEvents = await this.pool.querySync(RELAYS, {
      kinds: [3],
      '#p': [pubkey],
      limit: 500
    });
    
    const userVideos = await this.getUserVideos(pubkey);
    const videoIds = userVideos.map(v => v.id);
    
    let totalLikes = 0;
    if (videoIds.length > 0) {
      const batchSize = 20;
      for (let i = 0; i < videoIds.length; i += batchSize) {
        const batch = videoIds.slice(i, i + batchSize);
        const likeEvents = await this.pool.querySync(RELAYS, {
          kinds: [7],
          '#e': batch,
          limit: 500
        });
        totalLikes += likeEvents.length;
      }
    }
    
    return {
      following: followingCount,
      followers: followerEvents.length,
      likes: totalLikes
    };
  }

  public async follow(pubkey: string): Promise<void> {
    await this.ensureInitialized();
    
    const events = await this.pool.querySync(RELAYS, {
      kinds: [3],
      authors: [this.publicKey!],
      limit: 1
    });
    
    let tags: string[][] = [];
    if (events.length > 0) {
      tags = events[0].tags.filter(t => t[0] === 'p');
    }
    
    if (!tags.some(t => t[1] === pubkey)) {
      tags.push(['p', pubkey]);
    }
    
    const event: UnsignedEvent = {
      kind: 3,
      created_at: Math.floor(Date.now() / 1000),
      pubkey: this.publicKey!,
      tags,
      content: ''
    };
    
    const signedEvent = await this.signEvent(event);
    await this.pool.publish(RELAYS, signedEvent);
  }

  public async unfollow(pubkey: string): Promise<void> {
    await this.ensureInitialized();
    
    const events = await this.pool.querySync(RELAYS, {
      kinds: [3],
      authors: [this.publicKey!],
      limit: 1
    });
    
    if (events.length === 0) return;
    
    const tags = events[0].tags.filter(t => !(t[0] === 'p' && t[1] === pubkey));
    
    const event: UnsignedEvent = {
      kind: 3,
      created_at: Math.floor(Date.now() / 1000),
      pubkey: this.publicKey!,
      tags,
      content: ''
    };
    
    const signedEvent = await this.signEvent(event);
    await this.pool.publish(RELAYS, signedEvent);
  }

  public async isFollowing(pubkey: string): Promise<boolean> {
    await this.ensureInitialized();
    
    const events = await this.pool.querySync(RELAYS, {
      kinds: [3],
      authors: [this.publicKey!],
      limit: 1
    });
    
    if (events.length === 0) return false;
    
    return events[0].tags.some(t => t[0] === 'p' && t[1] === pubkey);
  }

  public async zapUser(targetPubkey: string, lnurl: string, amountSats: number = 21): Promise<void> {
    await this.ensureInitialized();
    if (!this.usingExtension) {
      toast.error("A NIP-07 extension is required to send a Zap.");
      throw new Error("NIP-07 extension required for zapping");
    }

    try {
      const zapEvent = await this.extension.zap(targetPubkey, amountSats * 1000, lnurl);
      if (zapEvent) {
        toast.success(`‚ö° Zap of ${amountSats} sats sent!`);
        console.log('‚úÖ Zap successful, event published by extension:', zapEvent);
      } else {
        toast.error('Zap was cancelled or failed in the extension.');
      }
    } catch (e: any) {
      console.error("‚ùå Zap failed:", e);
      toast.error(`Zap failed: ${e.message}`);
      throw e;
    }
  }


  public async getLikedVideos(): Promise<VideoData[]> {
    await this.ensureInitialized();
    
    const likeEvents = await this.pool.querySync(RELAYS, {
      kinds: [7],
      authors: [this.publicKey!],
      limit: 100
    });
    
    const videoIds = likeEvents
      .map(e => e.tags.find(t => t[0] === 'e')?.[1])
      .filter(Boolean) as string[];
    
    if (videoIds.length === 0) return [];
    
    const videoEvents = await this.pool.querySync(RELAYS, {
      kinds: [VIDEO_KIND],
      ids: videoIds
    });
    
    return videoEvents
      .map(event => this.parseVideoEvent(event as VideoEvent))
      .sort((a, b) => b.createdAt - a.createdAt);
  }

  public clearVideoCache(pubkey?: string): void {
    if (pubkey) {
      this.userVideosCache.delete(pubkey);
    } else {
      this.userVideosCache.clear();
    }
  }
}

export const nostrClient = new NostrClient();

--- END OF FILE: ./src/core/nostr.ts ---



--- START OF FILE: ./src/core/webtorrent.ts ---

import WebTorrent from 'webtorrent';
import type { Torrent, TorrentFile } from 'webtorrent';
import { Buffer } from 'buffer';
const TRACKER_OPTS = {
  announce: [
    'wss://tracker.btorrent.xyz',
    'wss://tracker.openwebtorrent.com', 
    'wss://tracker.webtorrent.dev:443/announce',
  ],
};

const arrayBufferToHex = (buffer: ArrayBuffer): string => {
  return Array.from(new Uint8Array(buffer))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
};

class WebTorrentClient {
  private client: WebTorrent.Instance;
  private torrents: Map<string, Torrent> = new Map();
  private seedingTorrents: Map<string, Torrent> = new Map();

  constructor() {
    this.client = new WebTorrent();
    
    console.log('üöÄ WebTorrent client initialized');
    
    this.client.on('error', (err: string | Error) => {
      console.error('‚ùå WebTorrent CLIENT ERROR:', err);
    });

    setInterval(() => {
      const clientRatio = isNaN(this.client.ratio) ? 0 : this.client.ratio;
      console.log('üìä WebTorrent Stats:', {
        torrents: this.client.torrents.length,
        ratio: clientRatio.toFixed(2),
        downloadSpeed: `${(this.client.downloadSpeed / 1024).toFixed(2)} KB/s`,
        uploadSpeed: `${(this.client.uploadSpeed / 1024).toFixed(2)} KB/s`,
        progress: this.client.progress,
        peersCount: this.client.torrents.reduce((acc, t) => acc + t.numPeers, 0)
      });
    }, 5000);
  }

  public seed(file: File): Promise<string> {
    console.log('üå± Starting to seed file:', {
      name: file.name,
      size: `${(file.size / 1024 / 1024).toFixed(2)} MB`,
      type: file.type
    });

    return new Promise((resolve) => {
      const existingTorrent = this.client.torrents.find(t => 
        t.files && t.files[0] && t.files[0].name === file.name
      );
      
      if (existingTorrent) {
        this.seedingTorrents.set(existingTorrent.magnetURI, existingTorrent);
        resolve(existingTorrent.magnetURI);
        return;
      }

      this.client.seed(file, TRACKER_OPTS, (torrent: Torrent) => {
        console.log('‚úÖ Seeding torrent successfully created!');
        console.log('FULL MAGNET URI:', torrent.magnetURI);

        this.setupTorrentLogging(torrent, 'SEEDER');
        this.seedingTorrents.set(torrent.magnetURI, torrent);
        this.torrents.set(torrent.magnetURI, torrent);
        
        resolve(torrent.magnetURI);
      });
    });
  }

  public async stream(magnetURI: string, element: HTMLVideoElement, expectedHash?: string) {
    console.log('üé¨ Starting stream for magnet URI:', magnetURI.substring(0, 50) + '...');
    
    const infoHash = magnetURI.match(/btih:([a-f0-9]{40})/i)?.[1];
    if (infoHash) {
      const existingByHash = this.client.torrents.find(t => 
        t.infoHash?.toLowerCase() === infoHash.toLowerCase()
      );
      
      if (existingByHash) {
        console.log('üì¶ Found existing torrent by infoHash');
        await this.attachToElement(existingByHash, element, expectedHash);
        return;
      }
    }

    const seedingTorrent = this.seedingTorrents.get(magnetURI);
    if (seedingTorrent) {
      console.log('üì§ We are seeding this torrent');
      await this.attachToElement(seedingTorrent, element, expectedHash);
      return;
    }

    const cachedTorrent = this.torrents.get(magnetURI);
    if (cachedTorrent) {
      console.log('üì¶ Using cached torrent');
      await this.attachToElement(cachedTorrent, element, expectedHash);
      return;
    }

    console.log('üÜï Adding new torrent to client...');
    
    try {
      const torrent = this.client.add(magnetURI, TRACKER_OPTS);
      
      this.torrents.set(magnetURI, torrent);
      this.setupTorrentLogging(torrent, 'DOWNLOADER');
      
      const onMetadata = () => {
        this.attachToElement(torrent, element, expectedHash).catch(err => {
          console.error('Attach failed:', err);
          this.destroyTorrent(magnetURI);
          throw err;
        });
      };

      if (torrent.ready) {
        onMetadata();
      } else {
        torrent.on('metadata', onMetadata);
      }
      
      torrent.on('error', (err) => {
        console.error('‚ùå Torrent error:', err);
        this.destroyTorrent(magnetURI);
      });
      
    } catch (error: any) {
      if (error.message?.includes('duplicate')) {
        console.log('‚ö†Ô∏è Duplicate torrent, finding existing...');
        const existing = this.client.torrents.find(t => 
          t.magnetURI === magnetURI || t.infoHash === infoHash
        );
        if (existing) {
          await this.attachToElement(existing, element, expectedHash);
        }
      } else {
        console.error('‚ùå Error adding torrent:', error);
        this.destroyTorrent(magnetURI);
        throw error;
      }
    }
  }

  private async attachToElement(torrent: Torrent, element: HTMLVideoElement, expectedHash?: string): Promise<void> {
    return new Promise((resolve, reject) => {
      console.log(`[Attach] Initial check - ready: ${torrent.ready}, files: ${torrent.files ? torrent.files.length : 'undefined'}`);
      
      const performAttach = async () => {
        if (!torrent.files || torrent.files.length === 0) {
          reject(new Error('No files available in torrent'));
          return;
        }

        const file: TorrentFile | undefined = torrent.files.find(f => 
          /\.(mp4|webm|m4v)$/i.test(f.name)
        );

        if (!file) {
          reject(new Error('No video file found in torrent'));
          return;
        }

        console.log('üìπ Found video file:', {
          name: file.name,
          size: `${(file.length / 1024 / 1024).toFixed(2)} MB`
        });
        
        element.pause();
        element.src = '';
        element.load();
        
        try {
          file.appendTo(element);
          console.log('‚úÖ Video streaming started');

          file.once('done', async () => {
            console.log('Video fully downloaded, verifying integrity...');
            try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† const buffer = await new Promise<Buffer>((resolve, reject) => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† file.getBuffer((err, buffer) => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (err) return reject(err);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!buffer) return reject(new Error('Buffer is empty'));
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† resolve(buffer);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† ¬† });
              const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
              const computedHash = arrayBufferToHex(hashBuffer);

              if (expectedHash && computedHash !== expectedHash) {
                throw new Error(`Hash mismatch: expected ${expectedHash}, got ${computedHash}`);
              }

              console.log('‚úÖ Integrity verified');
            } catch (err) {
              console.error('‚ùå Integrity check failed:', err);
              element.src = '';
              element.load();
              element.dispatchEvent(new Event('error'));
              import('react-hot-toast').then(({ toast }) => toast.error('Video integrity check failed'));
            }
          });

          resolve();
        } catch (err) {
          reject(err);
        }
      };

      if (torrent.files && torrent.files.length > 0) {
        performAttach();
      } else {
        if (torrent.ready) {
          console.log('‚è≥ Polling for files (ready torrent)');
          const maxWait = 50;
          let attempts = 0;
          const interval = setInterval(() => {
            attempts++;
            if (torrent.files && torrent.files.length > 0) {
              clearInterval(interval);
              performAttach();
            } else if (attempts >= maxWait) {
              clearInterval(interval);
              reject(new Error('Files poll timeout'));
            }
          }, 100);
        } else {
          console.log('‚è≥ Waiting for metadata event');
          const onMetadata = () => {
            performAttach().catch(reject);
          };
          torrent.on('metadata', onMetadata);
          setTimeout(() => {
            torrent.removeListener('metadata', onMetadata);
            reject(new Error('Metadata timeout'));
          }, 10000);
        }
      }
    });
  }

  private setupTorrentLogging(torrent: Torrent, role: string) {
    const prefix = `[${role}:${torrent.infoHash?.substring(0, 6)}]`;
    
    torrent.on('warning', (err: Error | string) => {
      console.warn(`${prefix} ‚ö†Ô∏è Warning:`, err);
    });

    torrent.on('error', (err: Error | string) => {
      console.error(`${prefix} ‚ùå Error:`, err);
    });

    torrent.on('wire', (_wire: any, addr?: string) => {
      console.log(`${prefix} üîå PEER CONNECTED:`, addr || 'unknown', `(total: ${torrent.numPeers})`);
    });

    torrent.on('noPeers', (announceType?: string) => {
      console.warn(`${prefix} üòî No peers via ${announceType}`);
    });
  }

  public remove(magnetURI: string) {
    console.log('üå± Keeping torrent for seeding:', magnetURI.substring(0, 30) + '...');
    return;
  }
  
  public destroyTorrent(magnetURI: string): void {
    let torrent = this.torrents.get(magnetURI);
    if (!torrent) {
      torrent = this.client.torrents.find(t => t.magnetURI === magnetURI);
    }
    if (!torrent) {
      console.log('‚ö†Ô∏è No torrent found to destroy:', magnetURI.substring(0, 30) + '...');
      return;
    }

    this.torrents.delete(magnetURI);
    this.seedingTorrents.delete(magnetURI);

    this.client.remove(torrent);
    console.log('üí• Destroyed torrent:', magnetURI.substring(0, 30) + '...');
  }
}

export const webTorrentClient = new WebTorrentClient();

--- END OF FILE: ./src/core/webtorrent.ts ---



--- START OF FILE: ./src/core/reputation.ts ---

// src/core/reputation.ts

interface ReputationState {
  alpha: number; // Positive evidence (likes, etc.)
  beta: number;  // Negative evidence (reports, etc.)
}

export class ReputationManager {
  private state: Map<string, ReputationState> = new Map();

  private initializeUser(pubkey: string): void {
    if (!this.state.has(pubkey)) {
      this.state.set(pubkey, { alpha: 1, beta: 1 }); // Neutral prior (Beta(1,1))
    }
  }

  public getReputationScore(pubkey: string): number {
    this.initializeUser(pubkey);
    const { alpha, beta } = this.state.get(pubkey)!;
    return alpha / (alpha + beta); // Score in [0,1]
  }

  public recordLike(likedUserPubkey: string, likerPubkey: string): void {
    this.initializeUser(likedUserPubkey);
    this.initializeUser(likerPubkey);

    const likerRep = this.getReputationScore(likerPubkey);
    const increase = likerRep * 0.05; // 5% of liker's rep as positive signal
    const state = this.state.get(likedUserPubkey)!;
    state.alpha += increase;
    console.log(`[Reputation] +${increase.toFixed(4)} alpha for ${likedUserPubkey.slice(0,10)}... (liker rep: ${likerRep.toFixed(3)})`);
  }

  public recordReport(reportedUserPubkey: string, reporterPubkey: string, velocityMultiplier: number): void {
    this.initializeUser(reportedUserPubkey);
    this.initializeUser(reporterPubkey);

    const reporterRep = this.getReputationScore(reporterPubkey);
    const penalty = reporterRep * 10 * velocityMultiplier; // Base 10 * reporter rep * velocity
    const state = this.state.get(reportedUserPubkey)!;
    state.beta += penalty;
    console.log(`[Reputation] +${penalty.toFixed(4)} beta for ${reportedUserPubkey.slice(0,10)}... (reporter rep: ${reporterRep.toFixed(3)}, velocity: ${velocityMultiplier})`);
  }
}

--- END OF FILE: ./src/core/reputation.ts ---



--- START OF FILE: ./src/core/ipfs.ts ---

import { create } from '@ipfs/upload-client';
 
 // Replace with environment variables in a real application
 const IPFS_PROJECT_ID = import.meta.env.VITE_IPFS_PROJECT_ID;
 const IPFS_PROJECT_SECRET = import.meta.env.VITE_IPFS_PROJECT_SECRET;
 
 const auth = 'Basic ' + btoa(IPFS_PROJECT_ID + ':' + IPFS_PROJECT_SECRET);
 const ipfs = create({ url: 'https://ipfs.infura.io:5001', headers: { authorization: auth } });
 
 class IPFSClient {
   public async uploadFile(file: File): Promise<string> {
     console.log('üìÅ Uploading to IPFS:', file.name);
     const { cid } = await ipfs.add(file);
     const cidString = cid.toString();
     console.log('‚úÖ IPFS CID:', cidString);
     return cidString;
   }
 
   public getFileUrl(cid: string): string {
     return `https://ipfs.io/ipfs/${cid}`;
   }
 }
 
 export const ipfsClient = new IPFSClient();

--- END OF FILE: ./src/core/ipfs.ts ---



--- START OF FILE: ./src/core/profiles.ts ---

import { SimplePool, finalizeEvent, UnsignedEvent, getPublicKey } from 'nostr-tools';
import { bytesToHex, hexToBytes } from '@noble/hashes/utils';

export interface UserProfile {
  pubkey: string;
  name?: string;
  about?: string;
  picture?: string;
  banner?: string;
  nip05?: string;
  lud06?: string;
  lud16?: string;
  created_at?: number;
}

const RELAYS = [
  'wss://relay.damus.io',
  'wss://relay.snort.social',
  'wss://nos.lol',
];

class ProfileManager {
  private pool = new SimplePool();
  private profileCache = new Map<string, UserProfile>();
  private secretKey: Uint8Array | null = null;
  public publicKey: string | null = null;
  private usingExtension: boolean = false;
  private extension: any = null;
  
  constructor() {
    this.extension = typeof window !== 'undefined' ? (window as any).nostr : null;
    this.usingExtension = !!this.extension;

    if (!this.usingExtension) {
      const sk = localStorage.getItem('nostr_sk');
      if (sk) {
        this.secretKey = hexToBytes(sk);
        this.publicKey = getPublicKey(this.secretKey);
      } else {
        throw new Error('No Nostr keys found');
      }
    } else {
      this.publicKey = null;
      this.secretKey = null;
    }
  }
  
  private async ensureInitialized(): Promise<void> {
    if (this.publicKey) return;

    if (this.usingExtension) {
      this.publicKey = await this.extension.getPublicKey();
    }
  }

  private async signEvent(unsigned: UnsignedEvent): Promise<any> {
    await this.ensureInitialized();
    if (this.usingExtension) {
      return await this.extension.signEvent(unsigned);
    } else {
      return finalizeEvent(unsigned, this.secretKey!);
    }
  }

  public async getProfile(pubkey: string): Promise<UserProfile> {
    if (this.profileCache.has(pubkey)) {
      return this.profileCache.get(pubkey)!;
    }
    
    try {
      const events = await this.pool.querySync(RELAYS, {
        kinds: [0],
        authors: [pubkey],
        limit: 1
      });
      
      if (events.length === 0) {
        const minimal: UserProfile = { pubkey };
        this.profileCache.set(pubkey, minimal);
        return minimal;
      }
      
      const profileEvent = events[0];
      const content = JSON.parse(profileEvent.content);
      
      const profile: UserProfile = {
        pubkey,
        name: content.name,
        about: content.about,
        picture: content.picture,
        banner: content.banner,
        nip05: content.nip05,
        lud06: content.lud06,
        lud16: content.lud16,
        created_at: profileEvent.created_at
      };
      
      this.profileCache.set(pubkey, profile);
      return profile;
      
    } catch (error) {
      console.error('Failed to fetch profile:', error);
      const minimal: UserProfile = { pubkey };
      this.profileCache.set(pubkey, minimal);
      return minimal;
    }
  }
  
  public async updateMyProfile(updates: Partial<UserProfile>): Promise<void> {
    await this.ensureInitialized();
    
    const currentProfile = this.profileCache.get(this.publicKey!) || { pubkey: this.publicKey! };
    const mergedProfile = { ...currentProfile, ...updates };
    
    const content = {
      name: mergedProfile.name || '',
      about: mergedProfile.about || '',
      picture: mergedProfile.picture || '',
      banner: mergedProfile.banner || '',
      nip05: mergedProfile.nip05 || '',
      lud06: mergedProfile.lud06 || '',
      lud16: mergedProfile.lud16 || '',
    };
    
    const event: UnsignedEvent = {
      kind: 0,
      created_at: Math.floor(Date.now() / 1000),
      pubkey: this.publicKey!,
      tags: [],
      content: JSON.stringify(content)
    };
    
    const signedEvent = await this.signEvent(event);
    
    const results = await this.pool.publish(RELAYS, signedEvent);
    
    this.profileCache.set(this.publicKey!, {
      ...mergedProfile,
      pubkey: this.publicKey!,
      created_at: event.created_at
    });
    
    console.log('‚úÖ Profile updated:', results);
  }
  
  public getSecretKey(): string {
    if (this.usingExtension) {
      throw new Error('Using NIP-07 extension');
    }
    return bytesToHex(this.secretKey!);
  }
  
  public clearCache(): void {
    this.profileCache.clear();
  }
  
  public getCachedProfile(pubkey: string): UserProfile | undefined {
    return this.profileCache.get(pubkey);
  }
}

let profileManagerInstance: ProfileManager | null = null;

export function getProfileManager(): ProfileManager {
  if (!profileManagerInstance) {
    profileManagerInstance = new ProfileManager();
  }
  return profileManagerInstance;
}

--- END OF FILE: ./src/core/profiles.ts ---



--- START OF FILE: ./src/main.tsx ---

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
 // Phase 3: Register PWA if supported (handled by Vite plugin, but manual check for custom logic)
 if ('serviceWorker' in navigator) {
   window.addEventListener('load', () => {
     navigator.serviceWorker.register('/sw.js')
       .then(reg => console.log('‚úÖ SW registered'))
       .catch(err => console.error('‚ùå SW registration failed', err));
   });
 }
createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

--- END OF FILE: ./src/main.tsx ---



--- START OF FILE: ./tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

--- END OF FILE: ./tsconfig.json ---



--- START OF FILE: ./dist/index.html ---

<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="ethereum-dapp" content="false">
  <title>FloReelz</title>
  <script type="module" crossorigin src="/assets/index-OjQY5m7V.js"></script>
  <link rel="stylesheet" crossorigin href="/assets/index-qxxImkXr.css">
</head>
  <body>
    <div id="root"></div>
  </body>
</html>

--- END OF FILE: ./dist/index.html ---



--- START OF FILE: ./package.json ---

{
  "name": "nostr-tok-ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@noble/hashes": "^2.0.0",
    "bittorrent-tracker": "^11.2.2",
    "nostr-tools": "^2.16.2",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-hot-toast": "^2.6.0",
    "swiper": "^12.0.1",
    "webtorrent": "^2.8.4",
    "@ipfs/upload-client": "^1.0.0",
    "workbox-window": "^7.1.0",
    "workbox-precaching": "^7.1.0",
    "workbox-routing": "^7.1.0",
    "workbox-strategies": "^7.1.0",
    "workbox-cacheable-response": "^7.1.0",
    "workbox-expiration": "^7.1.0",
    "idb": "^8.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@types/webtorrent": "^0.110.1",
    "@vitejs/plugin-react": "^5.0.0",
    "eslint": "^9.33.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.39.1",
    "vite": "^7.1.2",
    "vite-plugin-node-polyfills": "^0.24.0",
    "vite-plugin-pwa": "^0.20.6"
  }
}

--- END OF FILE: ./package.json ---



--- START OF FILE: ./tsconfig.app.json ---

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

--- END OF FILE: ./tsconfig.app.json ---




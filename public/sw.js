import { clientsClaim } from 'workbox-core';
 import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
 import { registerRoute } from 'workbox-routing';
 import { NetworkFirst } from 'workbox-strategies';
 import { CacheableResponsePlugin } from 'workbox-cacheable-response';
 import { ExpirationPlugin } from 'workbox-expiration';
 import { openDB } from 'idb';
 
 self.skipWaiting();
 clientsClaim();
 
 // Precache all of the assets generated by your build process.
 precacheAndRoute(self.__WB_MANIFEST);
 cleanupOutdatedCaches();
 
 // Custom handler for video blobs: Cache in IDB if successful fetch
 const VIDEO_DB = 'video-cache';
 const dbPromise = openDB(VIDEO_DB, 1, {
   upgrade(db) {
     db.createObjectStore('blobs', { keyPath: 'url' });
   },
 });
 
 registerRoute(
   ({ request }) => request.destination === 'video' || request.url.endsWith('.mp4') || request.url.endsWith('.webm'),
   async ({ request }) => {
     try {
       // Try network first
       const response = await fetch(request);
 
       // If successful, clone, cache, and store in IDB for persistence
       const responseClone = response.clone();
       const cache = await caches.open('video-blobs');
       await cache.put(request, responseClone);
 
       const blob = await response.blob();
       const db = await dbPromise;
       await db.put('blobs', { url: request.url, blob, timestamp: Date.now() });
 
       return response;
     } catch (err) {
       // If network fails, try the cache
       const cache = await caches.open('video-blobs');
       const cachedResponse = await cache.match(request);
       if (cachedResponse) {
         return cachedResponse;
       }
 
       // If cache fails, try IDB as the last resort
       const db = await dbPromise;
       const stored = await db.get('blobs', request.url);
       if (stored) {
         return new Response(stored.blob, {
           headers: { 'Content-Type': 'video/mp4' },
         });
       }
       throw err;
     }
   }
 );
